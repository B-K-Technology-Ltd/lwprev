{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to LightWare's Developer Portal","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"code/landing-moving-platform/","title":"LightWare Sample","text":""},{"location":"code/landing-moving-platform/#landing-on-a-moving-vehicle","title":"Landing on a Moving Vehicle","text":"<p>This sample code is to accompany the content explaining how to leverage the LW20/c and the DJI M350 to develop a logic to land on a moving vehicle. The robotic element to make this a production-viable system is hyper simplified by design and should not be considered as production-ready in its current state.</p>"},{"location":"code/landing-moving-platform/#principles","title":"Principles","text":"<p>This code is establishing a connection with the DJI M350 using the Payload SDK and observes in a control loop the results of four LW20/C until the results reflect of a relative flat surface identified as a commit moment to finally send command to the aircraft to land.</p>"},{"location":"code/landing-moving-platform/#project-structure","title":"Project Structure","text":"Folder Description libraries Contains all the libraries dependencies that are local sources Contains all source code for the project, including headers sources/dji Contains the PayloadSDK Sample - modded to work with this path structure sources/lightware Contains the LightWare LW20/c implementation to interface with the sensors"},{"location":"code/landing-moving-platform/#lw20c-interface","title":"LW20/c Interface","text":"<p>This project uses a software defined representation of the sensor configuration as an 'array'.</p> <p>This allows the main code to be structured, but isn't strictly required for function.</p>"},{"location":"code/landing-moving-platform/#installing-dependencies","title":"Installing dependencies","text":""},{"location":"code/landing-moving-platform/#dji","title":"DJI","text":"<p>This project uses the PayloadSDK sample. You'll need to configure it and install the dependencies as covered here:</p> <p>https://developer.dji.com/doc/payload-sdk-tutorial/en/quick-start/quick-guide/raspberry-pi.html</p>"},{"location":"code/landing-moving-platform/#compiling-instructions","title":"Compiling Instructions","text":"<p>This project uses a traditional CMake flow. From the root folder (where the CMakeLists.txt file is):</p> <pre><code>mkdir build;\ncd build;\ncmake ..;\nmake -j4;\nmake install;\n</code></pre>"},{"location":"code/landing-moving-platform/#running-the-app","title":"Running the app","text":"<p>From the build folder:</p> <pre><code>./lander\n</code></pre>"},{"location":"code/landing-moving-platform/LICENSE/","title":"LICENSE","text":"<p>Copyright 2024 LightWare Ltd</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"landing-moving-platform/","title":"M350 Landing on a Moving Platform","text":"<p>In this scenario, we are going to walk through the steps to add a capability to the DJI M350 which isn't present on the vehicle by default: The ability to land on a moving platform.</p> <p>Such platform can be a ground, aerial or a marine vehicle.  We will focus on the marine context to set the scene, because its application is more grounded.  Even a stopped vessel will still experience movements, so it is up to the drone to be able to handle it.</p> <p>Specifically, let's assume we are in the context of an inspection.</p> <p></p> <p>As you can see, the boat will be subjected to the movement of the water.  This will force its deck to be moving along three translation and three rotation axis. For a safe landing, an undamaged and reusable drone, we need to achieve a clean landing.</p> <p>This means we need to understand the condition of the boat landing pad, take a decision and execute the landing.</p> <p>We will go through all the details in the plan part of this tutorial.</p> <p>Note</p> <p>As the scope of this tutorial is to focus on how to use our products, we will skim through the other components and only cover the extent necessary for the whole solution to be reproducible and extendable. We will provide insight on how to explore this further and productize it, should this be something you would like to pursue.</p>"},{"location":"landing-moving-platform/components/","title":"Components","text":"<p>Let's go over the components for this solution and more importantly, cover why these would be leveraged, and where improvements are possible.</p>"},{"location":"landing-moving-platform/components/#parts-list","title":"Parts List","text":"Image Component Role Quantity DJI M350 Main Vehicle 1 LW20/C Landing Deck Plane Detection 4 Raspberry Pi 5 + SD Card Onboard Compute 1 Raspberry Pi 5 Cooling Kit Cooling for Onboard Compute  Note: This is not strictly necessary for this exercise, but future proofs the setup. 1 DJI E-Port Kit Payload SDK Interface 1 5A/5V Voltage Regulator Voltage regulator for the Pi 5 which requires 5V/5A while the E-Port 5V rail is limited to 2A 1 I2C Breakout Board Ad-hoc I2C bus hardware for all the sensors 1 USB to TTL Cable Connect the UART from the devkit to the Pi 1 LW20C Mounting Brackets Holding the LW20/C against the rails 4 Lidar Mounting Rails Holding the LW20/C in an array configuration 2 Compute and E-Port Mounting Kit Holding the E-Port and the Raspberry pi in place 1 Voltage Regulator/I2C Bus Mount Holding the Voltage Regulator and the I2C Bus breakout in place 1 XT30 Power Cables Provide power to the voltage regulator. Note: You can make these yourself if you feel up to it. This example uses 16AWG which is much more than needed. 1 Female Dupont Cables Power from voltage regulator to Pi and I2C wiring between Pi and Bus breakout. Note: You can make these yourself if you feel up to it - We're going to crimp the LW20 cables anyway. It's also quite convenient to buy ready made cable and cut/strip them to your need 6 M1.6 x 8mm Counter Sunk Screws Secure the clips to the rails 12 (4x3) M2.5 x 4mm Heat-set Insert Allows to attach he voltage regulator and easily remove/reinstall 4 M3 x 4mm Heat-set Insert Allows to attach he voltage regulator and easily remove/reinstall 4 M2.5 x 6mm Screws Secure the Raspberry Pi to the Mount 4 M3 x 6mm Screws Secure the Voltage Regulator and the I2C Breakout to the Mount 6 M3x8mm Standoffs Used to elevate the voltage regulator and the I2C breakout 6 M3 x 8mm Screws Secure the Back Compute/E-port Mount &amp; Back of the rails to the Vehicle 4 M3 x 10mm Screws Secure Front of the rails to the Vehicle 2 M3 x 15mm Screws Secure the Front Compute/E-port Mount 2 Zip Ties - 6 inch Secure Cables to Lidar Rails and top mount 3-5 BluTack Secure the EPort and Cables to the vehicle 1 Dupont Female headers + Crimper Simple connection of the LW20/C to the Raspberry Pi 1 28AWG silicon wire kit Misc. Wiring 1"},{"location":"landing-moving-platform/components/#dji-m350","title":"DJI M350","text":"<p>It's a good PayloadSDK enabled Aircraft with a great track record of being a workhorse with inspections - including a great range of top of the line payloads.</p>"},{"location":"landing-moving-platform/components/#lw20c","title":"LW20/C","text":"<p>We chose the LW20 for its range and its small form factor.  It's tempting to look at a multi-point lidar (like a 3D lidar), but it's not really necessary and the form factors would be significantly impacting the vehicle performance and time in the air.</p> <p>By choosing a small lidar unit and leveraging software, we create a lightweight, yet powerful solution which gives us everything we need.</p>"},{"location":"landing-moving-platform/components/#raspberry-pi-5-e-port-kit","title":"Raspberry Pi 5 + E-Port Kit","text":"<p>Chosen for its compute capabilities and its wide availability, the Raspberry Pi 5 is a good mid-size computer that's instantaneously available.  There are many other choices that can navigate the range of solutions from lower power at smaller footprint or higher power as a bigger footprint.</p> <p>For the focused context of this scenario, this is plentiful.</p> <p>The E-Port Kit is a simple solution which is also widely available and affordable. </p> <p>Note</p> <p>Neither are particularly elegant solution that will make the end result feel like a real product and the natural next step  would be developing a custom compute/E-Port breakout board in a clean package - which is not particularly difficult to achieve once the product capabilities has been validated.</p>"},{"location":"landing-moving-platform/components/#mounting-hardware","title":"Mounting Hardware","text":"<p>We chose to mount the LW20/C in a location that can allow for its placement to be both delivering on its expectations and remain out of the way of other critical components.</p> <p>All the parts are chosen to be modular, leveraging our mounting bracket which you can easily acquire from our store, or print yourself using our CAD files available in our resource center</p> <p>Now that we have all the parts involved, we can move onto putting the kit together.</p>"},{"location":"landing-moving-platform/conclusion/","title":"Conclusion","text":"<p>As we got over all aspects of getting a LightWare based project, we want to leave you with the right level of understanding of the high level pictures of such projects.</p> <p>We hope we have demystified the hardware aspect by simplifying the access to all components, so you can get into the software space as quickly as possible.</p> <p>We hope you see that the software is incredibly simple to get results yet has virtually no end to the sophistication and the value you can create with our sensors.</p> <p>We hope this has inspired you to think about how our products can unlock the next generation of advanced robotic behavior with drones but also with any other platforms.</p> <p>Regardless, feel free to continue reading as we cover other scenarios on this portal.</p>"},{"location":"landing-moving-platform/hardware/","title":"Hardware","text":"<p>Let's put the hardware together.</p> <p>Before you begin, make sure you have all the parts from the previous section.</p>"},{"location":"landing-moving-platform/hardware/#sensors","title":"Sensors","text":""},{"location":"landing-moving-platform/hardware/#preparation","title":"Preparation","text":"<p>First, we are going to prepare the rails and the clips that will attach the sensors on the belly of the aircraft.</p> <p>Secure the clips using the counter sunk screws as shown in this picture:</p> <p></p> <p>Next, we need to prepare the termination of the sensor to use dupont connectors. Out of the package, you will notice that the LW20/c comes with free wires. This is to give you options as to how to integrate, but in this case, we are going to use dupont connectors for convenience.</p> <p></p> <p>Crimp the black (<code>GND</code>), red (<code>VCC</code>), white (<code>RX/SCL</code>) and yellow (<code>TX/SDA</code>) wires individually, then encase them in a connector in this order.</p> <p></p>"},{"location":"landing-moving-platform/hardware/#mounting","title":"Mounting","text":"<p>Let's start by attaching the 3D printed bracket under the M350. </p> <p>Flip the aircraft on its 'head' (this is why we do this now, because the computer will be there once we are done). Remove and save the payload screws in case you want to remove the kit later.</p> <p></p> <p>Secure both rails using the M3x10mm on the front (where the payload is) and the M3x8mm for the back.</p> <p></p> <p>Clip the sensor to the printed parts and use blutack (it may be a different color in your country) to hold the cables close to the body of the aircraft.</p> <p> </p> <p>Note</p> <p>There are obviously more resilient ways to secure the cables for production deployment, but our approach here is of R&amp;D and quick validation of the end-to-end system.</p> <p>You may choose to pass the cables and zip tie it all. The rails are ready for this, but you may need to extend the length of the wires for the back sensors.</p> <p>Otherwise, you can simply guide and putty the cables along the side of the aircraft while making sure not to block the view of the obstacle avoidance sensors.</p> <p>Once you have secured all four sensors, you are ready to move to the next step.</p>"},{"location":"landing-moving-platform/hardware/#compute-unit","title":"Compute Unit","text":"<p>Next, we are going to look at mounting the compute unit on the top of the aircraft.</p>"},{"location":"landing-moving-platform/hardware/#preparations","title":"Preparations","text":"<p>First, we will use the M2.5 heat-set inserts for the Raspberry Pi posts on the compute mount.  To insert them, simply use a soldering iron at the melting temperature of the plastic you use for printing the model. Pull out when sufficiently inserted.</p> <p>Note</p> <p>The heat-set inserts are an optional improvements. If you want to skip them, you can simply use coarse screws - such as wood screws - into the plastic directly.</p> <p></p> <p>Next, we will prepare the additional board for the voltage regulator that will provide the bulk of the power to the Raspberry Pi and the I2C breakout board.</p> <p>Note</p> <p>You can choose other options for the I2C bus and the voltage regulator as long as you provide what's necessary for the pi to work.</p> <p>First, we place the heat-set inserts as done before.</p> <p></p> <p>Next we are going to prepare the power cables. If you've opted to the ready made cables, you can skip this. If you want to make your own:</p> <p>Cut two set of black and red pairs of the 20AWG silicon cable: 12cm or 4 3/4\" for the power to the Pi; 16cm of 6 1/4\" for the power from the E-port Dev Kit.</p> <p>The Pi cable (12cm) will be crimped and set in a two line dupont connector</p> <p></p> <p>The E-Port Dev Kit will be soldered to an XT30 connector.</p> <p></p>"},{"location":"landing-moving-platform/hardware/#mounting_1","title":"Mounting","text":""},{"location":"landing-moving-platform/hardware/#raspberry-pie-port","title":"Raspberry Pi/E-Port","text":"<p>Grab the top mount and let's start with the E-Port Kit. It will sit in the bottom, under the Raspberry Pi. Place the E-Port kit as seen on the picture below, making sure that it sits in between the securing post.</p> <p></p> <p>Note</p> <p>You can secure it with zip ties or bluetac. The putty will do a great work, while the Raspberry Pi posts will prevent it to fly away in case of failure.</p> <p>Also, note the orientation as it will matter greatly. The \"Drone\" USB-C port should be facing starboard side of the mount.</p> <p>Verify that it isn't moving before moving to the next step.</p> <p>Before we move to the Pi, now is a good time to connect the USB/TTL cable to the pins on the E-Port as you'll be able to see the markings on the PCB.</p> <p>You can also plug in the USB-C cable that came with the kit, making sure the B side is showing upwards.</p> <p></p> <p>Note</p> <p>The USB-C cable used for DJI development aren't regular USB-C cable. They aren't reversable. This is why they are noted with a A side and a B side. Pay close attention to the orientation as described in the DJI developer documentation:  </p> <p>Don't plug to the aircraft just yet.</p> <p>Time to attach the Raspberry Pi. You can choose to bring it with a case if you choose, but the mount we offer is coming with a through hole installation that's only compatible with the naked board or using the official case. Regardless, using the M2.5x6mm screws, secure the raspberry pi with the connectors facing the back of the aircraft.</p> <p>Don't over tighten.</p> <p></p>"},{"location":"landing-moving-platform/hardware/#voltage-regulator-and-i2c-breakout","title":"Voltage Regulator and I2C Breakout","text":"<p>To finish the add-on board, use the M3x6mm screws to secure the voltage regulator and the I2C bus breakout to the side board.</p> <p></p> <p>Next, connect to the input terminals the E-Port power cable and the Pi power cable to the output.</p> <p></p> <p>Note</p> <p>We will set up the voltage converter soon, but for now do not power anything.</p> <p>At this point the side board is fully assembled.</p>"},{"location":"landing-moving-platform/hardware/#assembly","title":"Assembly","text":"<p>First, we need to prepare the SDCard for the Raspberry Pi. Follow these instructions to get it done</p> <p>Once finished, place the SD Card in the Pi's slot.</p> <p>Next, clip the side board to the front of the Pi's mount. </p> <p></p> <p>Note</p> <p>The round clip would be enough to secure it, but if you want, you can secure them further with zip ties.</p> <p>Connect the XT30 power cable to the E-Port Dev Kit's unregulated power connector.</p> <p></p> <p>Connect the short USB-C cable between the device USB port of the E-Port dev kit and the Raspberry Pi's - This will be our fast data line.</p> <p></p> <p>Coil the USB to TTL cable around the base of the mount and connect the USB-A connector to one of the Raspberry Pi's. You can also zip tie it against the frame.</p> <p></p> <p>You should have something looking like this:</p> <p>Note</p> <p> Wiring diagram from DJI's Developer Documentation</p> <p>Now we can connect the I2C pins to the bus and to the Raspberry Pi.</p> <p>Using the Dupont cables, connect each of the I2C lines to the Raspberry Pi pins. </p> <p>Save the pin 4 &amp; 6 for the power input out of the voltage regulator.</p> <p>Warning</p> <p> <p>Pinout from pinout.xyz</p> <p></p> <p>At this point, the only unconnected cable should be the power cable output of the voltage regulator. We will plug it after we configured the regulator with the aircraft power.</p>"},{"location":"landing-moving-platform/hardware/#aircraft-installation","title":"Aircraft Installation","text":"<p>First, we mount the completed kit to the aircraft using the M3x8mm screws in the back and the M3x15mm in the front.</p> <p></p> <p>With the dev kit secured, it's time to connect the usb cable to the aircraft.</p> <p>Note</p> <p>As mentioned before, the USB-C cable used for DJI development aren't regular USB-C cable. They aren't reversable. This is why they are noted with a A side and a B side. Pay close attention to the orientation as described in the DJI developer documentation:  </p> <p>From this point onwards, the kit will be powered when the aircraft is on and able to break-out the data connection to the vehicle, but the Raspberry Pi won't be able to get all the power it wants.</p>"},{"location":"landing-moving-platform/hardware/#configurations","title":"Configurations","text":"<p>First, let's make sure the switches on the E-Port Dev Kit are switch correctly.</p> <p>By the drone USB-C side, make sure it's switch to on.</p> <p>By the payload USB-C side, make sure it's on host mode.</p> <p>Next, let's adjust the voltage regulator. The voltage regulator we chose is based on the XL4015 chip. The voltage is adjusted by working the potention-meter for the voltage limitations. In doubt, check markings on the PCB.</p> <p>Power on the aircraft, and confirm the voltage regulator is being powered on. The model we selected comes with a digital display and LEDs for that purpose.</p> <p>Warning</p> <p>If you use the same voltage regulator, the screen is only informational in nature. The modes to cycle won't change the output voltage.</p> <p>While powered on, use a multimeter on the output terminal to measure the output voltage. Turn the voltage limiting potentiometer until you reach 5V.</p> <p>Note</p> <p>It's not a bad idea now to leave the display to show the output current or power.</p> <p></p>"},{"location":"landing-moving-platform/hardware/#last-steps","title":"Last Steps","text":"<p>Power off the aircraft before continuing.</p> <p>Connect the output power lead to the power pins of the raspberry pi. Check the pin out above or the picture below.</p> <p></p> <p>And finally, the sensor lines to the I2C bus.</p> <p></p>"},{"location":"landing-moving-platform/hardware/#tidying-up","title":"Tidying Up","text":"<p>As a final step, attach all loose cables with zip ties. Make sure the kit is still as removable as possible for future maintenance and desk development.</p> <p></p>"},{"location":"landing-moving-platform/plan/","title":"Plan","text":"<p>In order to land a vehicle on a moving platform, we need to first characterize the situation. </p> <p>As we covered before, the deck of the boat will be moving in six degrees of freedom (three translation, three rotation) - even if some are less affected. All this motion will limit the window of opportunity for the vehicle to commit to a landing.</p> <p>To understand when the window of opportunity presents itself, we need to be able to observe in real time the plane represented by the deck, identify a moment of least-risk and commit with understanding of the motion capabilities of the vehicle and the structural strength of the drone.</p> <p></p> <p>The DJI M350 does have sensor packages all around itself, but most aren't accessible to developers. Fortunately, the PayloadSDK allows us to bring our sensors and our computer onboard. With these we can also bring our control logic and write a custom landing mode.</p> <p>So we can create an array of our LW20 lidar sensor to create an accurate reading of the distance to the ground, recreate the plane it represents, process it on an onboard computer, make our decision and execute the landing using the PayloadSDK.</p> <p>We will use custom-made hardware to secure the sensors and the computer onto the drone, with off-the-shelves components as to make this all the more accessible.</p> <p></p> <p>Now that we have a decent idea of how we can approach the problem, let's go over the components choice in details.</p>"},{"location":"landing-moving-platform/software/","title":"Software","text":""},{"location":"landing-moving-platform/software/#configuration","title":"Configuration","text":"<p>Before we dive into the code for the application, we need to set up all the baseline components</p>"},{"location":"landing-moving-platform/software/#payload-sdk-raspberry-pi","title":"Payload SDK &amp; Raspberry Pi","text":"<p>DJI covers really well how to get the Raspberry Pi setup, so follow the set up steps here</p> <p>Once you can run the sample code, we can move to the next step.</p> <p>Make sure to configure the Raspberry Pi to connect to your local wifi if available.</p> <p>Also, for convenience, make sure you have set up SSH access.</p> <p>While you are in the <code>Raspberry Pi Configuration</code> screen (from the top left menu), turn on \"I2C\"</p>"},{"location":"landing-moving-platform/software/#lw20c","title":"LW20/C","text":"<p>Each LW20/c comes configured with <code>0x66</code> as a I2C address, so we need to assign a new one to each device.</p> <p>To do so, you can use the LightWare Studio App.  Download the app, connect the sensor to a FTDI cable (the same type from the kit) and follow the instructions from the user manual.</p> <p>We want to have a dedicated address for each, so let's use <code>0x66</code>, <code>0x67</code>, <code>0x68</code>, <code>0x69</code>. You'll notice that in LightWare Studio, the value are in decimal. Simply increase by 1.</p> <p>Note</p> <p>Mark the address on each sensor as their positioning on the aircaft will matter for future logics.</p> <p>Reconnect all the sensors to the pi, and let's confirm that we can see them.</p> <p>On the pi, if you don't have them (unlikely scenario), install the i2c tooling: <pre><code>sudo apt-get install i2c-tools\n</code></pre></p> <p>Then, verify you can see the sensors using:</p> <pre><code>i2cdetect -y 1\n</code></pre> <p>You should see something like this:</p> <pre><code>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:                         -- -- -- -- -- -- -- -- \n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n60: -- -- -- -- -- -- 66 67 68 69 -- -- -- -- -- -- \n70: -- -- -- -- -- -- -- --  \n</code></pre> <p>You are now ready to dive into the code.</p>"},{"location":"landing-moving-platform/software/#project-code","title":"Project Code","text":"<p>First of all, all the code for we are going to go over is available here.</p> <p>The code is in itself, functionally simple. We started by writing several classes that will abstract the sensor, the array of them and the vehicle interaction. For the vehicle and to remain true to the content set by DJI, we used the same <code>Application</code> class from their sample code.</p> <p>Note</p> <p>Remember that this project isn't production ready. If you want to deliver this functionality you'll have to finish parts of the work.</p>"},{"location":"landing-moving-platform/software/#connecting-to-the-aircraft","title":"Connecting to the Aircraft","text":"<p>Because the Payload SDK does the work for us, once we are set up with the hardware, the work becomes as simple as this:</p> <pre><code>Application *vehicle = NULL;\n\nint main(int argc, char **argv) {\n    // Create the vehicle instance to connect\n    // We are reusing the Application object from DJI's sample for clarity only.\n    vehicle = new Application(argc, argv);\n</code></pre> <p>From this point on, the vehicle object can be used to abstract vehicle functions. </p> <p>Note</p> <p>The Payload SDK uses functions. These would be accessible in the global space, but structure with objects is a neater way to organize functions.</p>"},{"location":"landing-moving-platform/software/#connection-to-the-lw20c","title":"Connection to the LW20/c","text":"<p>Following the logic of abstraction, we are going to create two objects: <code>LW20</code> and <code>SensorArray</code>.</p> <p><code>LW20</code> is used to abstract a single sensor. This includes all controls and reads.</p> <p><code>SensorArray</code> is specific to this project and abstracts the four sensors in their physical configuration.</p> <p>Note</p> <p>A lot more effort can be put in these abstractions should the need come to expand on the current approach.  These classes are great places to contain it.</p> <p>First, we bring in all the headers needed for future work and then declare the class:</p> <pre><code>//\n// Created by LightWare.\n// LW20/c Interface\n//\n\n#pragma once\n\n#include &lt;iostream&gt;\n\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\n#include &lt;atomic&gt;\n#include &lt;thread&gt;\n#include &lt;sys/ioctl.h&gt;\n#include &lt;asm/ioctl.h&gt;\n\n#include &lt;fcntl.h&gt;\n#include &lt;string.h&gt;\n\nclass LW20 {\n</code></pre> <p>Then we define a <code>ioctl</code> configuration macro. This is necessary because we work on a Raspberry Pi 5 and the wiringPi which handles these variations isn't available.</p> <pre><code>#define I2C_SLAVE   0x0703\n</code></pre> <p>Next, we can implement the public interface which manages the life cycle of the abstraction and protected access to private information:</p> <pre><code>public:\n    LW20() {\n\n    }\n\n    ~LW20() {\n        this-&gt;disconnect();\n    }\n\n    void connect(int i2cAddress) {\n        _deviceAddress = i2cAddress;\n\n        const char *device = \"/dev/i2c-1\"; // This may change, wiringPi has a good discovery for this, but it's not available yet on pi5.\n        _fd = open (device, O_RDWR);\n\n        if (_fd == -1) {\n            std::cerr &lt;&lt; \"I2C Bus file could not be opened\" &lt;&lt; std::endl;\n        } else {\n            std::cerr &lt;&lt; \"I2C Bus opened on FD: \" &lt;&lt; _fd &lt;&lt; std::endl;\n\n            if (ioctl (_fd, I2C_SLAVE, i2cAddress) &lt; 0) {\n                std::cerr &lt;&lt; \"Unable to select I2C device: \" &lt;&lt; strerror(errno) &lt;&lt; std::endl;\n            } else {\n                _threadRunning.store(true, std::memory_order_relaxed);\n                _runningThread = std::thread(&amp;LW20::loop, this);\n            }\n        }\n    }\n\n    void disconnect() {\n        _threadRunning.store(false, std::memory_order_relaxed);\n        close(_fd);\n    }\n\n    int latestDistance() {\n        return this-&gt;_latestDistance.load(std::memory_order_relaxed);\n    }\n</code></pre> <p>Last, we do the private implementation which covers the internal loop running in a background thread to read the data from the sensor and the protected variables.</p> <pre><code>private:\n    std::atomic&lt;bool&gt; _threadRunning{false};\n    std::thread _runningThread;\n\n    int _deviceAddress = 0x66; // default factory value\n    int _fd;\n\n    std::atomic&lt;int&gt; _latestDistance{0}; // in cm\n\n    // Loop running in background thread.\n    void loop() {\n        while (_threadRunning.load(std::memory_order_relaxed))  {\n            unsigned char byte[2];\n            int res = read(_fd, byte, 2);\n\n            if (res == -1) {\n                std::cout &lt;&lt; \"I2C Device with address \" &lt;&lt; _deviceAddress &lt;&lt; \" was not available\" &lt;&lt; std::endl;\n            } else {\n                int distanceRead = (byte[0] &lt;&lt; 8) | byte[1];\n                std::cout &lt;&lt; \"[\" &lt;&lt; _deviceAddress &lt;&lt; \"] Distance: \" &lt;&lt; distanceRead &lt;&lt; \"cm\" &lt;&lt; std::endl;\n\n                _latestDistance.store(distanceRead, std::memory_order_relaxed);\n            }\n\n            usleep(250);\n        }\n    }\n};\n</code></pre> <p>Note</p> <p>The way this class is set, the address is defined during the connect function.  You could just as easily set it at allocation and have a parameter-less connect function. This is just a matter of preference.</p> <p>Now that we have a single sensor imlementation sorted, we need to move onto the <code>SensorArray</code></p> <p>Again, this object is a convenience luxury which makes the main business logic really light and abstracted behind trusted classes.</p> <p>As before, we start with the header call we will need and class declaration.</p> <pre><code>//\n// Created by LightWare.\n// Software representation of the LW20/c quad sensor array for platform detection\n//\n\n#pragma once\n\n#include \"LW20.h\"\n#include &lt;limits&gt;\n\nclass SensorArray {\n</code></pre> <p>The public interface handles the life cycle of the sensors:</p> <pre><code>public:\n    SensorArray() {\n        this-&gt;_sensor1 = new LW20();\n        this-&gt;_sensor2 = new LW20();\n        this-&gt;_sensor3 = new LW20();\n        this-&gt;_sensor4 = new LW20();\n    }\n\n    ~SensorArray() {\n        delete this-&gt;_sensor1;\n        delete this-&gt;_sensor2;\n        delete this-&gt;_sensor3;\n        delete this-&gt;_sensor4;\n    }\n\n    // Connects the entire array and start receiving distances\n    void connect() {\n        this-&gt;_sensor1-&gt;connect(0x66);\n        this-&gt;_sensor2-&gt;connect(0x67);\n        this-&gt;_sensor3-&gt;connect(0x68);\n        this-&gt;_sensor4-&gt;connect(0x69);\n    }\n\n    // Average distance in cm\n    int averageDistance() {\n        int sensor1LastRead = this-&gt;_sensor1-&gt;latestDistance();\n        int sensor2LastRead = this-&gt;_sensor2-&gt;latestDistance();\n        int sensor3LastRead = this-&gt;_sensor3-&gt;latestDistance();\n        int sensor4LastRead = this-&gt;_sensor4-&gt;latestDistance();\n\n        return (sensor1LastRead + sensor2LastRead + sensor3LastRead + sensor4LastRead)/4;\n    }\n\n    // Return the maximum differences between the closest and the furthest away hit\n    int maxDelta() {\n        int sensor1LastRead = this-&gt;_sensor1-&gt;latestDistance();\n        int sensor2LastRead = this-&gt;_sensor2-&gt;latestDistance();\n        int sensor3LastRead = this-&gt;_sensor3-&gt;latestDistance();\n        int sensor4LastRead = this-&gt;_sensor4-&gt;latestDistance();\n\n        int distances[4] = {sensor1LastRead, sensor2LastRead, sensor3LastRead, sensor4LastRead};\n        int lowest = std::numeric_limits&lt;int&gt;::max();\n        int highest = std::numeric_limits&lt;int&gt;::min();\n\n        for(int i = 0; i &lt; size; ++i) {\n            if(distances[i] &lt; lowest) {\n                lowest = distances[i];\n            }\n            if(distances[i] &gt; highest) {\n                highest = distances[i];\n            }\n        }\n\n        return highest - lowest;\n    }\n</code></pre> <p>Private interfaces aren't doing much except holding onto the sensor pointers.</p> <pre><code>private:\n    LW20 *_sensor1;\n    LW20 *_sensor2;\n    LW20 *_sensor3;\n    LW20 *_sensor4;\n\n};\n</code></pre> <p>Now that we have an abstraction for the vehicle and the sensor array, it's time to tie it all up together.</p>"},{"location":"landing-moving-platform/software/#plane-detection-logic","title":"Plane detection logic","text":"<p>As the purpose of this tutorial is to cover how to leverage the sensors, we are taking the most simplistic approach to solving this problem.  This means there is obviously a lot of room for improvements towards delivering a resilient and production ready solution. We will cover a few next steps should you want to take it further after we covered the simple solution we offer.</p> <p>Back to the <code>main.cpp</code> file in the <code>main</code> function, after we created the abstraction for the vehicle, we create the abstraction for the sensor array and connect it.</p> <p>After this, we assume we are in checking to land logic. We loop until the condition met is hit, then we exit the loop and trigger the landing:</p> <pre><code>int main(int argc, char **argv) {\n    // Create the vehicle instance to connect\n    // We are reusing the Application object from DJI's sample for clarity only.\n    vehicle = new Application(argc, argv);\n\n    sensorArray = new SensorArray();\n    sensorArray-&gt;connect();\n\n    // Check loop\n    bool checkingToLand = true;\n    int flatEnough = 10; // in cm; 10cm -&gt; ~15\u00b0 plane\n\n    while (checkingToLand) {\n        int maxDelta = sensorArray-&gt;maxDelta();\n\n        // Condition to determine a landing opportunity.\n        if (maxDelta &lt;= flatEnough &amp;&amp; maxDelta &gt; 0) {\n            checkingToLand = false;\n            break;\n        }\n    }\n</code></pre> <p>As you can see this is incredibly simple in this form so here are extra next steps for your consideration:</p>"},{"location":"landing-moving-platform/software/#maintaining-the-application-active-until-triggered-from-the-ground","title":"Maintaining the application active until triggered from the ground.","text":"<p>This current code will enter in checking to land logic as soon as it's launched. It's not something that's practical in the real world. </p> <p>What you'd want is for this app to launch with the life cycle of the vehicle and the logic entering once a pilot, operator or logic triggers it. We can't even cover all the way to handle these three scenarios, but assuming you have a pilot and a ground application, you can leverage MOP. MOP is a feature of the MobileSDK and PayloadSDK which allows a MobileSDK application to send custom commands to a PayloadSDK application. MOP has multiple names in the DJI world. It's also refered to SDK Interconnection and Pipeline  on the Android MSDK.</p> <p>Regardless, they will allow you to build a button on the UI of a MobileSDK app that can trigger this code to enter 'checking to land' logic.</p>"},{"location":"landing-moving-platform/software/#following-the-landing-target","title":"Following the landing target.","text":"<p>This is another element we skipped over because there is so many ways to go over it.</p> <p>You could use a dedicated camera sensor, or the existing PayloadSDK stream.</p> <p>Regardless, you'll likely reuse the triggering we covered before to enter 'follow the target' logic which itself could trigger the 'check to land' logic itself.</p>"},{"location":"landing-moving-platform/software/#landing-risk-validation","title":"Landing risk validation.","text":"<p>The logic we implemented assumes that committing to a landing from any height after reading a plane of about 15\u00b0 is safe. Big assumption.</p> <p>In a more practical sense, the plane validation of the ground would depend on the characteristic of your moving platform.</p> <p>For instance, landing on a ground vehicle on a road is likely to have a much more stable plane (smaller range, slower variation). On the other hand, landing on a sea ship will dramatically vary with the weather condition, the type of ship and the operation context.  If you land on an inspection boat after an off-shore wind turbine, you're likely looking at a fairly stable motion on all aspect than if you're landing on a military ship at sea state 4.</p>"},{"location":"landing-moving-platform/software/#landing-routine","title":"Landing routine","text":"<p>Finally, now that the logic is ready to commit, landing is a single function call behind an abstraction:</p> <pre><code>    if (!checkingToLand) {\n        // We exited the loop flagging we aren't checking to land, so we are landing.\n        std::cout &lt;&lt; \"Landing...\" &lt;&lt; std::endl;\n\n        vehicle-&gt;land();\n    }\n}\n</code></pre>"},{"location":"precision-positioning/","title":"M350 Landing on a Moving Platform","text":"<p>In this scenario, we are going to walk through the steps to add a capability to the DJI M350 which isn't present on the vehicle by default: The ability to land on a moving platform.</p> <p>The scope of this tutorial is to focus on how to use our products, so we will skim through the other components and only cover the extent necessary for the whole solution to be reproduceable.</p>"},{"location":"precision-positioning/#plan","title":"Plan","text":"<p>In order to land a vehicle on a moving platform, we need to first characterize the situation. In this case, moving platform implies a vehicle which landing platform will be affected by it motion.  There is obviously the translational effect, but also the three-dimensional effect on the plate which will limit the window of opportunity for the vehicle to commit to a landing.</p> <p>In the case of boat, the deck of boat will tilt in two axis in a way that could jeopardize the vehicle's safety.</p> <p>To understand when the window of opportunity presents itself, we need to be able to observe in real time the plane represented by the deck and identify a moment of least-risk and commit with understanding of the motion capabilities of the vehicle.</p> <p>INSERT DIAGRAM HERE</p> <p>Now that we have a decent idea of how we will approach this problem, we can start planning for the components at play and their roles.</p>"},{"location":"precision-positioning/components/","title":"Components","text":""},{"location":"precision-positioning/components/#components","title":"Components","text":"<p>To achieve this, we will leverage four LW20/C lidar sensors. These will be used to create a real-time, high frequency plane detection to be incorporated in a custom landing routine running on an onboard computer attached to the M350.</p> Component Role DJI M350 Main Vehicle LW20C Landing Deck Plane Detection Raspberry Pi 5 Onboard Compute DJI E-Port Kit PSDK Interface"},{"location":"precision-positioning/hardware/","title":"Hardware","text":""},{"location":"precision-positioning/hardware/#hardware","title":"Hardware","text":""},{"location":"precision-positioning/plan/","title":"M350 Landing on a Moving Platform","text":"<p>In this scenario, we are going to walk through the steps to add a capability to the DJI M350 which isn't present on the vehicle by default: The ability to land on a moving platform.</p> <p>The scope of this tutorial is to focus on how to use our products, so we will skim through the other components and only cover the extent necessary for the whole solution to be reproduceable.</p>"},{"location":"precision-positioning/plan/#plan","title":"Plan","text":"<p>In order to land a vehicle on a moving platform, we need to first characterize the situation. In this case, moving platform implies a vehicle which landing platform will be affected by it motion.  There is obviously the translational effect, but also the three-dimensional effect on the plate which will limit the window of opportunity for the vehicle to commit to a landing.</p> <p>In the case of boat, the deck of boat will tilt in two axis in a way that could jeopardize the vehicle's safety.</p> <p>To understand when the window of opportunity presents itself, we need to be able to observe in real time the plane represented by the deck and identify a moment of least-risk and commit with understanding of the motion capabilities of the vehicle.</p> <p>INSERT DIAGRAM HERE</p> <p>Now that we have a decent idea of how we will approach this problem, we can start planning for the components at play and their roles.</p>"},{"location":"precision-positioning/software/","title":"Software","text":""},{"location":"precision-positioning/software/#software","title":"Software","text":""},{"location":"spoi/","title":"M350 Landing on a Moving Platform","text":"<p>In this scenario, we are going to walk through the steps to add a capability to the DJI M350 which isn't present on the vehicle by default: The ability to land on a moving platform.</p> <p>The scope of this tutorial is to focus on how to use our products, so we will skim through the other components and only cover the extent necessary for the whole solution to be reproduceable.</p>"},{"location":"spoi/#plan","title":"Plan","text":"<p>In order to land a vehicle on a moving platform, we need to first characterize the situation. In this case, moving platform implies a vehicle which landing platform will be affected by it motion.  There is obviously the translational effect, but also the three-dimensional effect on the plate which will limit the window of opportunity for the vehicle to commit to a landing.</p> <p>In the case of boat, the deck of boat will tilt in two axis in a way that could jeopardize the vehicle's safety.</p> <p>To understand when the window of opportunity presents itself, we need to be able to observe in real time the plane represented by the deck and identify a moment of least-risk and commit with understanding of the motion capabilities of the vehicle.</p> <p>INSERT DIAGRAM HERE</p> <p>Now that we have a decent idea of how we will approach this problem, we can start planning for the components at play and their roles.</p>"},{"location":"spoi/components/","title":"Components","text":""},{"location":"spoi/components/#components","title":"Components","text":"<p>To achieve this, we will leverage four LW20/C lidar sensors. These will be used to create a real-time, high frequency plane detection to be incorporated in a custom landing routine running on an onboard computer attached to the M350.</p> Component Role DJI M350 Main Vehicle LW20C Landing Deck Plane Detection Raspberry Pi 5 Onboard Compute DJI E-Port Kit PSDK Interface"},{"location":"spoi/hardware/","title":"Hardware","text":""},{"location":"spoi/hardware/#hardware","title":"Hardware","text":""},{"location":"spoi/plan/","title":"M350 Landing on a Moving Platform","text":"<p>In this scenario, we are going to walk through the steps to add a capability to the DJI M350 which isn't present on the vehicle by default: The ability to land on a moving platform.</p> <p>The scope of this tutorial is to focus on how to use our products, so we will skim through the other components and only cover the extent necessary for the whole solution to be reproduceable.</p>"},{"location":"spoi/plan/#plan","title":"Plan","text":"<p>In order to land a vehicle on a moving platform, we need to first characterize the situation. In this case, moving platform implies a vehicle which landing platform will be affected by it motion.  There is obviously the translational effect, but also the three-dimensional effect on the plate which will limit the window of opportunity for the vehicle to commit to a landing.</p> <p>In the case of boat, the deck of boat will tilt in two axis in a way that could jeopardize the vehicle's safety.</p> <p>To understand when the window of opportunity presents itself, we need to be able to observe in real time the plane represented by the deck and identify a moment of least-risk and commit with understanding of the motion capabilities of the vehicle.</p> <p>INSERT DIAGRAM HERE</p> <p>Now that we have a decent idea of how we will approach this problem, we can start planning for the components at play and their roles.</p>"},{"location":"spoi/software/","title":"Software","text":""},{"location":"spoi/software/#software","title":"Software","text":""}]}